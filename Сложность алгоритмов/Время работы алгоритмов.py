""" Что влияет на время выполнения?

Бывает, что асимптотика одна, в время сильно разнится.
Дело в кеше. При обращении к элементу он сначала грузится в кеш из
оперативной памяти, потом в процессор и станет доступен для манипуляций
в коде.

Соотв., ели элемент уже был в кеше - доступ к нему быстрее
- Сложение, битовые операции - быстро
- Взятие по модулю, деление - самое медленное

Вывод: важна локальность данных. Это про то, что мы обращаемся к элементам не
хаотично, а к идущим подряд, соседним, например. Так они чаще попадают в кеш
и быстрее отзываются в следующие обращения.
Достать элемент из оперативки сильно дольше, чем из кеша


Branch prediction
------------------
Почему бывает разное время у одного кода?
Потому что на вход подаются сортированные и несортированне данные

Процессор пытается предугадать, в какую ветку условного оператора вы зайдете
и начинает выполнять вычисления заранее. Работает по принципу ИИ, опирается
на старые данные.

Например, на сортированных списках он понимает, что мы сначала постоянно
заходим в ветку, а когда перевалим через условный арьер - вообще заходить не
будем. Поэтому с несортированными массивами все дольше, там процессор
угадать не может


В Яваскрипте - BufferWriter
---------------------------
Накапливает данные для сохранения у себя
и когда набирает установленный объем - оптом грузит в базу, не тратит время на
постоянные мелкие обращения, не дергает лишний раз оперативную память
Например: цикл, который записывает в файл 100 букв М
Если обращаться к файлу, писать каждую последовательно - это 1000 открытий и
закрытий файла. А если накопить изменения и записать хотя бы в две партии 500
и 500 - это сильно улучшит дело

Но есть проблема - если в середине выбило ошибку - то не все будет в итоге
записано, часть зависнет в буфере
Поэтому для логирования это не используем


Передача данных по сети
------------------------
Не передают видео по пикселю, а пачку, которую потом кодек будет раскодировать
Отправить одно по сети чаще дольше, чем тысячу всего локально
"""