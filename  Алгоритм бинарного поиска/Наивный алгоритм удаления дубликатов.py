""" Эффективность алгоритма не только по времени считается, но
и по дополнительному расходу памяти, например, на создание подмассива

Удаление со сдвигом
Например, удаляем третий из пяти и получаем массив из 4 элементов, причем 4 и
5 сместились на одну клетку назад

Разница между ассоциированными и динамическими массивами:
А равны начальной длине, даже если из них убрать часть элементов
Д занимают ровно столько, сколько надо, без пустот

Вместо вспомогательного элемента можем использовать правую часть исходного
массива для поиска повторов
"""
import time


my_arr = [20, 15, 8, 11, 20, 14, 8]

# способ 1
tic1 = time.perf_counter()
my_set = list(set(my_arr))
toc1 = time.perf_counter()
print(my_set)
print(f"Вычисление заняло {toc1 - tic1:0.10f} секунд")


# способ 2 - оптимальный
tic1 = time.perf_counter()
for x in my_arr:
    if my_arr.count(x) > 1:
        my_arr.remove(x)
toc1 = time.perf_counter()
print(my_arr)
print(f"Вычисление заняло {toc1 - tic1:0.10f} секунд")


# способ 3
tic1 = time.perf_counter()
temp = []
[temp.append(x) for x in my_arr if x not in temp]
toc1 = time.perf_counter()
print(temp)
print(f"Вычисление заняло {toc1 - tic1:0.10f} секунд")

