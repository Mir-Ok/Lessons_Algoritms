""" Используем сортировку, добавим знание направление возрастания элементов

Теперь мы можем брать опорный элемент и удалять из рассмотрения сразу области
исходного списка, если элемент больше или меньше
Например, в числах от 1 до 100 ищем 45, опорным берем середину - 50.
Можем сразу выкинуть от 50 до 100, они все явно больше искомого

Бинарный - потому что делим массив каждый раз пополам (благодаря сортировке)

Разделяй и властвуй

Время выполнения имеет логарифмическую зависимость """

# реализация в коде, метод возвращает индекс искомого элемента или -1,
# если его нет

import math


def binary_search(array, index):
    left = 0
    right = array[-1]
    middle = math.floor((left + right) / 2)

    while left <= right:  # после добавим условия повторения
        # сначала опишем детали одной итерации цикла
        if array[middle] < index:  # рассмотрим правый подмассив
            left = middle + 1  # смещаем левую границу массива вправо
        elif array[middle] > index:
            fight = middle - 1  # смещаем правую границу массива влево
        else:
            return middle
    return -1


''' Мы гарантированно найдем элемент, потому что мы 
- отсекаем то, что нам точно не подходит, 
- движемся в нужную половину массива
- каждый раз массив делится пополам и остается только один 

Количество итераций N = 2**х, где x - количество элементов 
Это логарифм по основанию 2 от N - log_2_N 
То есть в какую степень надо возвести 2, чтобы получить N 
Например log_2_8 = 3, потому что 2**3 = 8 '''


